import numpy as np
import pytest

from GSEGUtils.util import AngleUnit, convert_angles, unique_rows_fast


class TestUtil:
    def test_bypass_immutability_decorator(self):
        # assert False
        pass

    def test_return_copy_decorator(self):
        # assert False
        pass


class TestConvertAngle:
    # Generated by chatgpt

    def test_rad_to_deg(self):
        rad_values = np.array([np.pi, np.pi / 2, np.pi / 4])
        expected_deg = np.array([180, 90, 45])
        np.testing.assert_array_almost_equal(
            convert_angles(rad_values, AngleUnit.RAD, AngleUnit.DEGREE), expected_deg
        )

    def test_deg_to_rad(self):
        deg_values = np.array([180, 90, 45])
        rad_values = np.array([np.pi, np.pi / 2, np.pi / 4])
        np.testing.assert_array_almost_equal(
            convert_angles(deg_values, AngleUnit.DEGREE, AngleUnit.RAD), rad_values
        )

    def test_deg_to_gon(self):
        deg_values = np.array([180, 90, 45])
        expected_gon = np.array([200, 100, 50])
        np.testing.assert_array_almost_equal(
            convert_angles(deg_values, AngleUnit.DEGREE, AngleUnit.GON), expected_gon
        )

    def test_gon_to_deg(self):
        gon_values = np.array([200, 100, 50])
        expected_deg = np.array([180, 90, 45])
        np.testing.assert_array_almost_equal(
            convert_angles(gon_values, AngleUnit.GON, AngleUnit.DEGREE), expected_deg
        )

    def test_gon_to_rad(self):
        gon_values = np.array([200, 100, 50])
        expected_rad = np.array([np.pi, np.pi / 2, np.pi / 4])
        np.testing.assert_array_almost_equal(
            convert_angles(gon_values, AngleUnit.GON, AngleUnit.RAD), expected_rad
        )

    def test_rad_to_gon(self):
        rad_values = np.array([np.pi, np.pi / 2, np.pi / 4])
        expected_gon = np.array([200, 100, 50])
        np.testing.assert_array_almost_equal(
            convert_angles(rad_values, AngleUnit.RAD, AngleUnit.GON), expected_gon
        )

    def test_same_unit_conversion(self):
        values = np.array([1, 2, 3])
        np.testing.assert_array_equal(
            convert_angles(values, AngleUnit.DEGREE, AngleUnit.DEGREE), values
        )

    def test_array_sizes(self):
        large_array = np.linspace(0, 100, 500)
        assert len(convert_angles(large_array, AngleUnit.RAD, AngleUnit.GON)) == 500

    def test_out_parameter(self, caplog):
        values = np.array([np.pi, np.pi / 2])
        out = np.zeros_like(values)
        convert_angles(values, AngleUnit.RAD, AngleUnit.DEGREE, out=out)
        expected = np.array([180, 90])
        np.testing.assert_array_almost_equal(out, expected)

        out = np.zeros_like(values)
        old_id = id(out)
        convert_angles(values, AngleUnit.RAD, AngleUnit.RAD, out=out)
        new_id = id(out)
        assert old_id == new_id
        assert np.all(out == values)

        # Nothing happens if the input is a float
        out = 2.0
        value = 3.0
        id_value = id(value)
        before_value = value
        id_out = id(out)
        before_out = out
        assert out != value
        returned = convert_angles(value, AngleUnit.RAD, AngleUnit.RAD, out=out)
        assert id_value == id(value)
        assert before_value == value  # hasn't changed
        assert id(out) == id_out
        assert before_out == out  # hasn't changed
        assert returned is None
        assert "Input values are not an ndarray" in caplog.text

    def test_inplace(self):
        values = np.array([np.pi, np.pi / 2])
        convert_angles(values, AngleUnit.RAD, AngleUnit.DEGREE, out=values)
        expected = np.array([180, 90])
        np.testing.assert_array_almost_equal(values, expected)

    def test_invalid_unit(self):
        values = np.array([np.pi, np.pi / 2])

        with pytest.raises(ValueError):
            convert_angles(values, "invalid_source", AngleUnit.DEGREE, out=values)

        with pytest.raises(ValueError):
            convert_angles(values, AngleUnit.RAD, "invalid_target", out=values)


# Tests written by Claude 3.5 Sonnet
def test_unique_rows_fast():
    # Test case 1: Basic functionality with distinct rows
    input_array = np.array([[1, 2], [3, 4], [5, 6]], dtype=np.int32)
    unique, inverse = unique_rows_fast(input_array)
    assert np.array_equal(unique, input_array)
    assert np.array_equal(inverse, [0, 1, 2])

    # Test case 2: Array with duplicate rows
    input_array = np.array([[1, 2], [3, 4], [1, 2], [5, 6], [3, 4]], dtype=np.int32)
    unique, inverse = unique_rows_fast(input_array)
    expected_unique = np.array([[1, 2], [3, 4], [5, 6]], dtype=np.int32)
    expected_inverse = [0, 1, 0, 2, 1]
    assert np.array_equal(unique, expected_unique)
    assert np.array_equal(inverse, expected_inverse)

    # Test case 3: Single row array
    input_array = np.array([[1, 2]], dtype=np.int32)
    unique, inverse = unique_rows_fast(input_array)
    assert np.array_equal(unique, input_array)
    assert np.array_equal(inverse, [0])

    # Test case 4: Higher dimensional data
    input_array = np.array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [7, 8, 9]], dtype=np.int32)
    unique, inverse = unique_rows_fast(input_array)
    expected_unique = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=np.int32)
    expected_inverse = [0, 1, 0, 2]
    assert np.array_equal(unique, expected_unique)
    assert np.array_equal(inverse, expected_inverse)

    # Test case 5: Compare with numpy's unique function
    large_array = np.random.randint(0, 100, size=(1000, 4), dtype=np.int32)
    unique_fast, inverse_fast = unique_rows_fast(large_array)
    unique_np, inverse_np = np.unique(large_array, axis=0, return_inverse=True)

    # Note: The order of unique rows might differ between implementations
    # so we need to check if they contain the same rows and inverse maps correctly
    assert unique_fast.shape == unique_np.shape
    assert inverse_fast.shape == inverse_np.shape

    # Verify that reconstructing the original array works the same way
    assert np.array_equal(unique_fast[inverse_fast], large_array)
    assert np.array_equal(unique_np[inverse_np], large_array)


def test_unique_rows_fast_performance():
    # Test case 5: Performance test with large array
    n_rows = 1_000_000
    n_cols = 5
    large_array = np.random.randint(0, 1000, size=(n_rows, n_cols), dtype=np.int32)

    # Add some duplicates
    large_array[n_rows // 2 :] = large_array[: n_rows // 2]

    # Time both implementations
    import time

    start_time = time.time()
    unique_fast, inverse_fast = unique_rows_fast(large_array)
    fast_time = time.time() - start_time

    start_time = time.time()
    unique_np, inverse_np = np.unique(large_array, axis=0, return_inverse=True)
    np_time = time.time() - start_time

    # Verify results are equivalent
    assert np.array_equal(unique_fast[inverse_fast], large_array)
    assert np.array_equal(unique_np[inverse_np], large_array)

    # Verify performance improvement (should be 5-10x faster)
    assert fast_time * 2 < np_time  # At least 2x faster
